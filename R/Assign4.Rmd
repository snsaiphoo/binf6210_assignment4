---
title: "Assign4"
output: html_document
---
##### Part 1: Data collection from NCBI ITS Genes
```{r}
# These are a list of the species we will be using
candida6_species_term <- paste0(
  '("Candida auris"[ORGN] OR ',
  '"Candida glabrata"[ORGN] OR ',
  '"Candida krusei"[ORGN] OR ',
  '"Candida albicans"[ORGN] OR ',
  '"Candida tropicalis"[ORGN] OR ',
  '"Candida parapsilosis"[ORGN])'
)

# This is the search term
candida6_ITS_term <- paste0(
  candida6_species_term,
  ' AND "internal transcribed spacer"[All Fields] AND 400:800[SLEN]'
)

candida6_ITS_term
```
This part of the code we are using the rentrez function to search NCBI for the 6 species. It returns 500 ITS sequences across the 6 species
```{r}
library(rentrez)

candida6_ITS_search <- entrez_search(
  db = "nuccore",
  term = candida6_ITS_term,
  retmax = 500,
  use_history = TRUE
)

candida6_ITS_search
candida6_ITS_search$count
length(candida6_ITS_search$ids)
candida6_ITS_search$web_history

```

Fetch these sequences and place in a FASTA file
```{r}

candida6_ITS_fasta <- entrez_fetch(
  db = "nuccore",
  web_history = candida6_ITS_search$web_history,
  rettype = "fasta",
  retmax = 500
)


write(
  candida6_ITS_fasta,
  file = "../data/raw/candida6_ITS_500.fasta",
  sep  = "\n"
)

```
Reading the FASTA into R
```{r}
library(Biostrings)

candida6_ITS_seqs <- readDNAStringSet("../data/raw/candida6_ITS_500.fasta")

length(candida6_ITS_seqs)          
summary(width(candida6_ITS_seqs))  

```
The data is slightly skewed to the right, but the values are consistent with ITS for Candida
```{r}
dfITS <- data.frame(
  ITS_Title = names(candida6_ITS_seqs),
  ITS_Sequence = paste(candida6_ITS_seqs)
)

# Base R species name extraction 
title_split <- strsplit(dfITS$ITS_Title, " ")

species_name <- sapply(
  title_split,
  function(x) {
    if (length(x) >= 3) {
      paste(x[2], x[3])
    } else {
      NA_character_
    }
  }
)

dfITS$Species_Name <- species_name
dfITS <- dfITS[, c("ITS_Title", "Species_Name", "ITS_Sequence")]
table(dfITS$Species_Name)



```
Adjust naming conventions so everything is consistent
```{r}

dfITS$Species_Name[dfITS$Species_Name == "Candidozyma auris"] <- "Candida auris"

dfITS$Species_Name[dfITS$Species_Name == "Pichia kudriavzevii"] <- "Candida krusei"

dfITS$Species_Name[dfITS$Species_Name == "Nakaseomyces glabratus"] <- "Candida glabrata"

table(dfITS$Species_Name)

```
For more data quality investigating, ill create a quick histogram comparing the species that are of high resistance concern vs the low resistance concern
```{r}

dfITS$Resistance_group <- NA

high_res <- c("Candida auris", "Candida glabrata", "Candida krusei")
low_res  <- c("Candida albicans", "Candida parapsilosis", "Candida tropicalis")

dfITS$Resistance_group[dfITS$Species_Name %in% high_res] <- "High resistance concern"
dfITS$Resistance_group[dfITS$Species_Name %in% low_res]  <- "Lower resistance concern"

dfITS$Seq_Length <- nchar(dfITS$ITS_Sequence)

hist(
  dfITS$Seq_Length[dfITS$Resistance_group == "High resistance concern"],
  main = "ITS Sequence Lengths: High Resistance Concern Species",
  xlab = "Sequence Length (bp)",
  col = "tomato",
  breaks = 20
)

hist(
  dfITS$Seq_Length[dfITS$Resistance_group == "Lower resistance concern"],
  main = "ITS Sequence Lengths: Lower Resistance Concern Species",
  xlab = "Sequence Length (bp)",
  col = "skyblue",
  breaks = 20
)

```
High-resistance group - noisier, multimodal, less standardized, smaller n
Low-resistance group - tighter, almost normal, consistent lengths, larger n

Lower resistance concern species have more standardized sequencing and much larger sample sizes, which produces a smoother and approximately normal distribution
```{r}

## Sample min ITS sequences per species ----

table(dfITS$Species_Name)

min_n <- min(table(dfITS$Species_Name))  

idx_by_species <- split(seq_len(nrow(dfITS)), dfITS$Species_Name)

set.seed(123)  

# Sample min_n indices per species
idx_sampled <- unlist(
  lapply(idx_by_species, function(idx) sample(idx, min_n))
)

# Subset dataframe
dfITS_subset <- dfITS[idx_sampled, ]

# Check that we have 19 per species
table(dfITS_subset$Species_Name)

# Making sure no missing sequences
sum(is.na(dfITS$ITS_Sequence))


write.csv(dfITS_subset,
          file = "../data/clean/candida6_ITS_minperSpecies.csv",
          row.names = FALSE)


```
##### Part 1.2: Data collection from NCBI ERG11 Genes
```{r}

erg11_gene_term <- paste0(
  '(',
  'ERG11[Gene] OR ',
  '"lanosterol 14-alpha demethylase"[Title] OR ',
  '"lanosterol 14 alpha demethylase"[Title] OR ',
  'CYP51[Gene]',
  ')'
)

length_term <- '1000:2500[SLEN]'

candida6_ERG11_term <- paste(
  candida6_species_term,
  "AND",
  erg11_gene_term,
  "AND",
  length_term
)

candida6_ERG11_term

```
```{r}

candida6_ERG11_search <- entrez_search(
  db          = "nuccore",
  term        = candida6_ERG11_term,
  retmax      = 500,      
  use_history = TRUE
)

candida6_ERG11_search$count
length(candida6_ERG11_search$ids)

```
```{r}
erg11_fasta <- entrez_fetch(
  db          = "nuccore",
  web_history = candida6_ERG11_search$web_history,
  rettype     = "fasta",
  retmax = 500,
  retmode     = "text"
)

writeLines(erg11_fasta, "../data/raw/candida6_ERG11_raw.fasta")

```
```{r}
candida6_ERG11_seqs <- readDNAStringSet("../data/raw/candida6_ERG11_raw.fasta")
length(candida6_ERG11_seqs)

seq_lengths <- width(candida6_ERG11_seqs)
summary(seq_lengths)

```
Theres a little bit of a skew, first and second quartile are quite close, whereas the max is not.
```{r}
dfERG11 <- data.frame(
  ERG11_Title = names(candida6_ERG11_seqs),
  ERG11_Sequence = paste(candida6_ERG11_seqs)
)

# Base R species name extraction 
title_split <- strsplit(dfERG11$ERG11_Title, " ")

species_name <- sapply(
  title_split,
  function(x) {
    if (length(x) >= 3) {
      paste(x[2], x[3])
    } else {
      NA_character_
    }
  }
)

dfERG11$Species_Name <- species_name
dfERG11 <- dfERG11[, c("ERG11_Title", "Species_Name", "ERG11_Sequence")]
table(dfERG11$Species_Name)


```
```{r}

dfERG11$Species_Name[dfERG11$Species_Name == "Candidozyma auris"] <- "Candida auris"

dfERG11$Species_Name[dfERG11$Species_Name == "Pichia kudriavzevii"] <- "Candida krusei"

dfERG11$Species_Name[dfERG11$Species_Name == "Nakaseomyces glabratus"] <- "Candida glabrata"

table(dfERG11$Species_Name)


```
```{r}

dfERG11$Resistance_group <- NA

high_res <- c("Candida auris", "Candida glabrata", "Candida krusei")
low_res  <- c("Candida albicans", "Candida parapsilosis", "Candida tropicalis")

dfERG11$Resistance_group[dfERG11$Species_Name %in% high_res] <- "High resistance concern"
dfERG11$Resistance_group[dfERG11$Species_Name %in% low_res]  <- "Lower resistance concern"

dfERG11$Seq_Length <- nchar(dfERG11$ERG11_Sequence)

hist(
  dfERG11$Seq_Length[dfERG11$Resistance_group == "High resistance concern"],
  main = "ERG11 Sequence Lengths: High Resistance Concern Species",
  xlab = "Sequence Length (bp)",
  col = "tomato",
  breaks = 20
)

hist(
  dfERG11$Seq_Length[dfERG11$Resistance_group == "Lower resistance concern"],
  main = "ERG11 Sequence Lengths: Lower Resistance Concern Species",
  xlab = "Sequence Length (bp)",
  col = "skyblue",
  breaks = 20
)
```
```{r}

## Sample min ERG11 sequences per species ----

table(dfERG11$Species_Name)

min_n <- min(table(dfERG11$Species_Name))  

idx_by_species <- split(seq_len(nrow(dfERG11)), dfERG11$Species_Name)

set.seed(123)  

# Sample min_n indices per species
idx_sampled <- unlist(
  lapply(idx_by_species, function(idx) sample(idx, min_n))
)

# Subset dataframe
dfERG11_subset <- dfERG11[idx_sampled, ]

# Check that we have 19 per species
table(dfERG11_subset$Species_Name)

# Making sure no missing sequences
sum(is.na(dfERG11$ERG11_Sequence))


write.csv(dfERG11_subset,
          file = "../data/clean/candida6_ERG11_minperSpecies.csv",
          row.names = FALSE)


```
## Part 2.1: Pairwise Distance Calculated for ITS
```{r}
library(DECIPHER)
library(Biostrings)

# Turn sequences into DNAStringSet
ITS_dna <- DNAStringSet(dfITS_subset$ITS_Sequence)

# Give useful names to the sequences (optional but nice)
names(ITS_dna) <- paste(dfITS_subset$Species_Name, seq_len(nrow(dfITS_subset)), sep = "_")

# Multiple sequence alignment (dataset is small so this is fine)
ITS_aln <- AlignSeqs(ITS_dna, processors = NULL)

# Pairwise distance matrix (proportion of mismatches)
ITS_dist <- DistanceMatrix(ITS_aln, type = "dist")  # can also try "dist" or "similarity"

# If you want a plain numeric matrix for saving/plotting:
ITS_dist_mat <- as.matrix(ITS_dist)

ITS_dist_mat[1:5, 1:5]

# Optional: save to file
write.csv(ITS_dist_mat,
          file = "../data/clean/ITS_pairwise_distance_matrix.csv",
          quote = FALSE)

```
Run the same thing to create the pairwise distances of ERG11
```{r}

library(DECIPHER)
library(Biostrings)

ERG11_dna <- DNAStringSet(dfERG11_subset$ERG11_Sequence)

# Give useful names to the sequences
names(ERG11_dna) <- paste(
  dfERG11_subset$Species_Name,
  seq_len(nrow(dfERG11_subset)),
  sep = "_"
)

# Multiple sequence alignment (dataset is moderate but still fine)
ERG11_aln <- AlignSeqs(ERG11_dna, processors = NULL)

# Pairwise distance matrix
ERG11_dist <- DistanceMatrix(ERG11_aln, type = "dist")

# Convert to matrix for viewing and saving
ERG11_dist_mat <- as.matrix(ERG11_dist)

# Peek at the first 5x5
ERG11_dist_mat[1:5, 1:5]

# Save to file
write.csv(
  ERG11_dist_mat,
  file = "../data/clean/ERG11_pairwise_distance_matrix.csv",
  quote = FALSE
)

```
## Part 2.1: Hierarchal Clustering for ITS and ERG11
```{r}
## 3.1 ITS hierarchical clustering ----

hc_ITS <- hclust(ITS_dist, method = "average")  # UPGMA

plot(
  hc_ITS,
  main = "Hierarchical Clustering of ITS Sequences",
  xlab = "",
  sub = "",
  cex = 0.6
)

## 3.2 ERG11 hierarchical clustering ----

hc_ERG11 <- hclust(ERG11_dist, method = "average")  # UPGMA

plot(
  hc_ERG11,
  main = "Hierarchical Clustering of ERG11 Sequences",
  xlab = "",
  sub = "",
  cex = 0.6
)

```
## Part 3.1: Feature Based Clustering ITS 
```{r}
# Feature Extraction

library(Biostrings)

compute_features_biostring <- function(seq_vec) {
  
  dna <- DNAStringSet(seq_vec)
  
  # Length
  length_vec <- width(dna)
  
  # Nucleotide counts (A, C, G, T)
  nuc_counts <- letterFrequency(dna, letters = c("A","C","G","T"))
  
  # GC content
  GC <- (nuc_counts[, "G"] + nuc_counts[, "C"]) / length_vec
  
  # Convert counts to frequencies
  nuc_freq <- nuc_counts / length_vec
  
  # Combine into a dataframe
  data.frame(
    Seq_Length = length_vec,
    GC_content = GC,
    A_freq = nuc_freq[, "A"],
    C_freq = nuc_freq[, "C"],
    G_freq = nuc_freq[, "G"],
    T_freq = nuc_freq[, "T"]
  )
}

```
ITS feature matrix + clustering
```{r}
## ITS feature matrix ----

ITS_features <- compute_features_biostring(dfITS_subset$ITS_Sequence)

# Add labels for later interpretation
ITS_features$Species <- dfITS_subset$Species_Name
ITS_features$Resistance_group <- dfITS_subset$Resistance_group

head(ITS_features)

```
Hierarchical Clustering for the ITS Sequences
```{r}
## Hierarchical clustering on ITS features ----

# Numeric features only
ITS_numeric <- ITS_features[, c("Seq_Length", "GC_content",
                                "A_freq", "C_freq", "G_freq", "T_freq")]

# Scale features so they are on comparable ranges
ITS_scaled <- scale(ITS_numeric)

# Distance and clustering
ITS_dist_feat <- dist(ITS_scaled, method = "euclidean")
ITS_hc_feat <- hclust(ITS_dist_feat, method = "average")

plot(
  ITS_hc_feat,
  labels = ITS_features$Species,
  main = "Feature-based Hierarchical Clustering of ITS Sequences",
  xlab = "",
  sub = "",
  cex = 0.6
)

```
## Part 3.2: Feature Based Clustering ERG11
```{r}
## ERG11 feature matrix ----

ERG11_features <- compute_features_biostring(dfERG11_subset$ERG11_Sequence)

ERG11_features$Species <- dfERG11_subset$Species_Name
ERG11_features$Resistance_group <- dfERG11_subset$Resistance_group

head(ERG11_features)

```
Clustering for ERG11
```{r}
## Hierarchical clustering on ERG11 features ----

ERG11_numeric <- ERG11_features[, c("Seq_Length", "GC_content",
                                    "A_freq", "C_freq", "G_freq", "T_freq")]

ERG11_scaled <- scale(ERG11_numeric)

ERG11_dist_feat <- dist(ERG11_scaled, method = "euclidean")
ERG11_hc_feat <- hclust(ERG11_dist_feat, method = "average")

plot(
  ERG11_hc_feat,
  labels = ERG11_features$Species,
  main = "Feature-based Hierarchical Clustering of ERG11 Sequences",
  xlab = "",
  sub = "",
  cex = 0.6
)

```
## Silhouette Index for Alignment-Based Clustering

```{r}

library(cluster)
library(fpc)

# Convert species labels to numeric clusters
ITS_species <- as.factor(dfITS_subset$Species_Name)
ITS_cluster_labels <- as.numeric(ITS_species)

# Compute silhouette scores
sil_ITS <- silhouette(ITS_cluster_labels, ITS_dist)

# Average silhouette width
mean_sil_ITS <- mean(sil_ITS[, 3])
mean_sil_ITS

# Silhouette plot
plot(
  sil_ITS,
  border = NA,
  main = "Silhouette Plot – ITS Alignment-Based Clustering"
)


```

## Silhouette Plot - ERG11 Alignment-Based Clustering
```{r}
## Silhouette index for ERG11 alignment-based clustering ----

ERG11_species <- as.factor(dfERG11_subset$Species_Name)
ERG11_cluster_labels <- as.numeric(ERG11_species)

sil_ERG11 <- silhouette(ERG11_cluster_labels, ERG11_dist)

mean_sil_ERG11 <- mean(sil_ERG11[, 3])
mean_sil_ERG11

plot(
  sil_ERG11,
  border = NA,
  main = "Silhouette Plot – ERG11 Alignment-Based Clustering"
)

```
## Dunn Index
```{r}

library(fpc)

ITS_stats <- cluster.stats(
  d = as.matrix(ITS_dist),
  clustering = ITS_cluster_labels
)

ITS_stats$dunn


ERG11_stats <- cluster.stats(
  d = as.matrix(ERG11_dist),
  clustering = ERG11_cluster_labels
)

ERG11_stats$dunn


```
## PCA or NMDS Visualization
```{r}
## PCA for ITS feature-based clustering ----

ITS_pca <- prcomp(ITS_scaled)

plot(
  ITS_pca$x[,1], ITS_pca$x[,2],
  col = as.factor(ITS_features$Species),
  pch = 19,
  main = "PCA of ITS Features",
  xlab = "PC1", ylab = "PC2"
)
legend("topright", legend = levels(as.factor(ITS_features$Species)),
       col = 1:6, pch = 19, cex = 0.8)

```
```{r}
## PCA for ERG11 feature-based clustering ----

ERG11_pca <- prcomp(ERG11_scaled)

plot(
  ERG11_pca$x[,1], ERG11_pca$x[,2],
  col = as.factor(ERG11_features$Species),
  pch = 19,
  main = "PCA of ERG11 Features",
  xlab = "PC1", ylab = "PC2"
)
legend("topright", legend = levels(as.factor(ERG11_features$Species)),
       col = 1:6, pch = 19, cex = 0.5)

```
```{r}
library(vegan)

## NMDS for ITS alignment-based clustering ----
ITS_nmds <- metaMDS(as.matrix(ITS_dist))

plot(
  ITS_nmds$points,
  col = as.factor(dfITS_subset$Species_Name),
  pch = 19,
  main = "NMDS – ITS Distances"
)
legend("bottomright", legend = levels(as.factor(dfITS_subset$Species_Name)),
       col = 1:6, pch = 19, cex = 0.6)

```
```{r}
## NMDS for ERG11 alignment-based clustering ----
ERG11_nmds <- metaMDS(as.matrix(ERG11_dist))

plot(
  ERG11_nmds$points,
  col = as.factor(dfERG11_subset$Species_Name),
  pch = 19,
  main = "NMDS – ERG11 Distances"
)
legend("topright", legend = levels(as.factor(dfERG11_subset$Species_Name)),
       col = 1:6, pch = 19, cex = 0.6)
```




























